package cmd

import (
	"fmt"
	"github.com/eddylee1010/gin-generator/generator"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"html/template"
	"log/slog"
	"strings"
)

// Column cliéœ€è¦çš„ä¿¡æ¯
type Column struct {
	Name       string // Go å­—æ®µåï¼ˆå¤§é©¼å³°ï¼‰
	TagName    string // åŸå§‹æ•°æ®åº“å­—æ®µå
	Type       string // Go ç±»å‹
	IsNullable bool
	IsPrimary  bool
	IsPointer  bool
}

// TableTemplateData å­˜å‚¨æ¨¡æ¿æ•°æ®
type TableTemplateData struct {
	StructName       string   // Go ç»“æ„ä½“å
	TableName        string   // æ•°æ®åº“è¡¨å
	SearchableFields []Column // ç”¨äºæŸ¥è¯¢çš„å­—æ®µï¼ˆç›®å‰å¯ä»¥æ˜¯æ‰€æœ‰éä¸»é”®å­—æ®µï¼‰
	AllFields        []Column // æ‰€æœ‰å­—æ®µ
	ModulePath       string   // æ¨¡å—è·¯å¾„ï¼ˆç”¨äº importï¼‰
	ProjectName      string
}

// ColumnInfo å­˜å‚¨æ•°æ®åº“åŸå§‹ä¿¡æ¯
type ColumnInfo struct {
	ColumnName string `gorm:"column:COLUMN_NAME"`
	DataType   string `gorm:"column:DATA_TYPE"`
	ColumnKey  string `gorm:"column:COLUMN_KEY"`
	IsNullable string `gorm:"column:IS_NULLABLE"`
}

var genServiceCmd = &cobra.Command{
	Use:   "service",
	Short: "ğŸ˜˜ ç”Ÿæˆserviceå±‚ä»£ç  ğŸ˜„",
	PreRunE: func(cmd *cobra.Command, args []string) error {
		err := generator.InitTemplates()

		viper.SetConfigFile("gen-config.yaml")
		err = viper.ReadInConfig()
		if err != nil {
			return err
		}

		return err
	},
	Run: func(cmd *cobra.Command, args []string) {
		generateServiceFiles(viper.GetString("project_name"))
	},
	SilenceErrors: true,
	SilenceUsage:  true,
}

func init() {
	genCmd.AddCommand(genServiceCmd)
}

func generateServiceFiles(projectName string) {
	// 	1.	è¿æ¥æ•°æ®åº“
	db, err := gorm.Open(mysql.Open("msysg:n7iFhRNyRZZdGJYP@tcp(8.130.123.223:3306)/msysg"))
	if err != nil {
		fmt.Println("âŒ è¿æ¥æ•°æ®åº“å¤±è´¥")
		return
	}
	//	2.	è¯»å–æ‰€æœ‰è¡¨å
	tableNames, err := getAllTableNamesByGorm(db)
	if err != nil {
		return
	}
	for _, tableName := range tableNames {

		//	3.	è¯»å–æ¯å¼ è¡¨çš„å­—æ®µç»“æ„ï¼ˆå­—æ®µåã€ç±»å‹ã€æ˜¯å¦ä¸ºä¸»é”®ç­‰ï¼‰
		info, err := loadTableInfoByGorm(db, tableName, projectName)
		if err != nil {
			slog.Error("âŒ è¯»å–è¡¨ç»“æ„å¤±è´¥", "err", err)
			return
		}
		// è¡¥å……ä¿¡æ¯
		info.ProjectName = projectName
		slog.Debug("", "", info)
		generator.RenderTemplateToFile(generator.ServiceTemplate, info, "services/"+tableName+".go")
	}
	//	4.	è½¬æ¢ä¸ºæ¨¡æ¿æ•°æ®ç»“æ„
	//	5.	æ¸²æŸ“ç”Ÿæˆæ¯ä¸ªè¡¨çš„ service.go æ–‡ä»¶
	// 6. ç”Ÿæˆinternalçš„common
	// åˆå§‹åŒ–serviceæ¨¡ç‰ˆ
	ServiceInternalTemplate, err := template.New("service_internal").Parse(`// Code generated by gin-generator . DO NOT EDIT.
// Code generated by gin-generator . DO NOT EDIT.
// Code generated by gin-generator . DO NOT EDIT.
package internal

type PageInfo struct {
	Page     int ` + "`form:\"page\"`" + `
	PageSize int ` + "`form:\"pageSize\"`" + `
}`)
	if err != nil {
		slog.Error("Failed to Parse template", "error", err)
		return
	}
	generator.RenderTemplateToFile(ServiceInternalTemplate, nil, "services/internal/common.go")
}

func getAllTableNamesByGorm(db *gorm.DB) ([]string, error) {
	var tables []string
	err := db.Raw(`SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = DATABASE()`).Scan(&tables).Error
	return tables, err
}

func loadTableInfoByGorm(db *gorm.DB, tableName, modulePath string) (*TableTemplateData, error) {

	var columnInfos []ColumnInfo
	err := db.Raw(`
		SELECT COLUMN_NAME, DATA_TYPE, COLUMN_KEY, IS_NULLABLE
		FROM INFORMATION_SCHEMA.COLUMNS
		WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = ?
		ORDER BY ORDINAL_POSITION
	`, tableName).Scan(&columnInfos).Error
	if err != nil {
		return nil, err
	}

	var columns []Column
	var searchable []Column
	structName := toCamelCase(tableName)

	for _, col := range columnInfos {
		goType, isPointer := mysqlTypeToGoType(col.DataType, col.IsNullable)
		c := Column{
			Name:       toCamelCase(col.ColumnName),
			TagName:    col.ColumnName,
			Type:       goType,
			IsNullable: col.IsNullable == "YES",
			IsPrimary:  col.ColumnKey == "PRI",
			IsPointer:  isPointer,
		}
		columns = append(columns, c)

		// è¿‡æ»¤createAt updateAt deleteAtå­—æ®µ
		if c.TagName == "created_at" || c.TagName == "updated_at" || c.TagName == "deleted_at" {
			continue
		}
		if !c.IsPrimary {
			searchable = append(searchable, c)
		}

	}

	return &TableTemplateData{
		StructName:       structName,
		TableName:        tableName,
		AllFields:        columns,
		SearchableFields: searchable,
		ModulePath:       modulePath,
	}, nil
}

func mysqlTypeToGoType(mysqlType string, nullable string) (goType string, isPointer bool) {
	switch mysqlType {
	case "int", "tinyint", "smallint":
		goType = "int32"
	case "bigint", "mediumint":
		goType = "int64"
	case "varchar", "text", "longtext", "mediumtext", "char":
		goType = "string"
	case "datetime", "timestamp", "date":
		goType = "time.Time"
	case "float", "double", "decimal":
		goType = "float64"
	case "bit":
		goType = "bool"
	default:
		goType = "string"
	}
	isPointer = nullable == "YES" && goType != "time.Time" && goType != "string"
	if isPointer {
		goType = "*" + goType
	}
	return
}

// toCamelCase å°†ä¸‹åˆ’çº¿åˆ†éš”çš„å­—ç¬¦ä¸²è½¬æ¢ä¸ºé©¼å³°å¼
func toCamelCase(s string) string {
	parts := strings.Split(s, "_")
	for i, p := range parts {
		if len(p) == 0 {
			continue
		}
		// å¦‚æœ åŒ…å«_id åˆ™è½¬ä½IDã€‚ä¸ºäº†å…¼å®¹gorm
		if p == "id" {
			parts[i] = "ID"
			continue
		}
		// æ­£å¸¸æƒ…å†µ
		parts[i] = strings.ToUpper(string(p[0])) + strings.ToLower(p[1:])
	}
	return strings.Join(parts, "")
}
